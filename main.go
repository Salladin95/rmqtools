package rmqtools

import (
	"encoding/json"
	"fmt"
	amqp "github.com/rabbitmq/amqp091-go"
	"log"
	"math"
	"time"
)

func ConnectToRabbit(rabbitURL string) (*amqp.Connection, error) {
	var counts int64
	var backOff = 1 * time.Second
	var connection *amqp.Connection

	for {
		c, err := amqp.Dial(rabbitURL)
		if err != nil {
			fmt.Println("RabbitMQ not yet ready...")
			counts++
		} else {
			log.Println("Connected to RabbitMQ!")
			connection = c
			break
		}

		if counts > 5 {
			fmt.Println(err)
			return nil, err
		}

		backOff = time.Duration(math.Pow(float64(counts), 2)) * time.Second
		log.Println("backing off...")
		time.Sleep(backOff)
		continue
	}

	return connection, nil
}

// DeclareExchange creates or declares a topic exchange on the given channel.
func DeclareExchange(ch *amqp.Channel, exchangeName string) error {
	return ch.ExchangeDeclare(
		exchangeName, // name of the exchange
		"topic",      // type of the exchange (topic)
		true,         // durable: the exchange survives broker restarts
		false,        // auto-deleted: the exchange is not deleted when there are no more queues bound to it
		false,        // internal: this is not an internal exchange used by other exchanges
		false,        // no-wait: do not wait for the server to confirm the exchange creation
		nil,          // arguments: additional settings for the exchange (none in this case)
	)
}

// DeclareRandomQueue creates or declares an anonymous exclusive queue on the given channel.
func DeclareRandomQueue(ch *amqp.Channel) (amqp.Queue, error) {
	return ch.QueueDeclare(
		"",    // name: a unique name is generated by the server (anonymous queue)
		false, // durable: the queue will not survive broker restarts
		false, // delete when unused: the queue will be deleted when there are no more consumers or bindings
		true,  // exclusive: the queue can only be used by the connection that created it
		false, // no-wait: do not wait for the server to confirm the queue creation
		nil,   // arguments: additional settings for the queue (none in this case)
	)
}

type Emitter struct {
	connection   *amqp.Connection
	exchangeName string
	topicName    string
}

func (e *Emitter) Setup() error {
	channel, err := e.connection.Channel()
	if err != nil {
		return err
	}

	defer channel.Close()
	return DeclareExchange(channel, e.exchangeName)
}

func (e *Emitter) Push(routingKey, data string) error {
	channel, err := e.connection.Channel()
	if err != nil {
		return err
	}
	defer channel.Close()

	log.Println("Pushing to channel")

	err = channel.Publish(
		e.topicName,
		routingKey,
		false,
		false,
		amqp.Publishing{
			ContentType: "text/plain",
			Body:        []byte(data),
		},
	)
	if err != nil {
		return err
	}

	return nil
}

func NewEventEmitter(conn *amqp.Connection, exchangeName, topicName string) (Emitter, error) {
	emitter := Emitter{
		connection:   conn,
		exchangeName: exchangeName,
		topicName:    topicName,
	}

	err := emitter.Setup()
	if err != nil {
		return Emitter{}, err
	}

	return emitter, nil
}

type Consumer struct {
	conn         *amqp.Connection
	exchangeName string
	queueName    string
	topicName    string
}

func NewConsumer(conn *amqp.Connection, exchangeName, queueName, topicName string) (Consumer, error) {
	consumer := Consumer{
		conn:         conn,
		exchangeName: exchangeName,
		queueName:    queueName,
		topicName:    topicName,
	}

	err := consumer.setup()
	if err != nil {
		return Consumer{}, err
	}

	return consumer, nil
}

func (consumer *Consumer) setup() error {
	channel, err := consumer.conn.Channel()
	if err != nil {
		return err
	}

	return DeclareExchange(channel, consumer.exchangeName)
}

type Payload struct {
	Name string `json:"name"`
	Data string `json:"data"`
}

func (consumer *Consumer) Listen(topics []string) error {
	ch, err := consumer.conn.Channel()
	if err != nil {
		return err
	}
	defer ch.Close()

	q, err := DeclareRandomQueue(ch)
	if err != nil {
		return err
	}

	for _, topic := range topics {
		ch.QueueBind(
			q.Name,
			topic,
			consumer.topicName,
			false,
			nil,
		)

		if err != nil {
			return err
		}
	}

	messages, err := ch.Consume(q.Name, "", true, false, false, false, nil)
	if err != nil {
		return err
	}

	forever := make(chan bool)
	go func() {
		for d := range messages {
			var payload Payload
			_ = json.Unmarshal(d.Body, &payload)

			go handlePayload(payload)
		}
	}()

	fmt.Printf("Waiting for message [Exchange, Queue] [logs_topic, %routingKey]\n", q.Name)
	<-forever

	return nil
}

func handlePayload(payload Payload) {
	switch payload.Name {
	case "auth":
	default:
		log.Panic("handlePayload: unknown payload name")
	}
}
